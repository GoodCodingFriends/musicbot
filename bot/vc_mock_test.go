// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package bot

import (
	"context"
	"sync"
)

var (
	lockVCMockClose    sync.RWMutex
	lockVCMockSpeaking sync.RWMutex
	lockVCMockWrite    sync.RWMutex
)

// VCMock is a mock implementation of VC.
//
//     func TestSomethingThatUsesVC(t *testing.T) {
//
//         // make and configure a mocked VC
//         mockedVC := &VCMock{
//             CloseFunc: func() error {
// 	               panic("mock out the Close method")
//             },
//             SpeakingFunc: func(in1 bool) error {
// 	               panic("mock out the Speaking method")
//             },
//             WriteFunc: func(in1 context.Context, in2 [][]byte) error {
// 	               panic("mock out the Write method")
//             },
//         }
//
//         // use mockedVC in code that requires VC
//         // and then make assertions.
//
//     }
type VCMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// SpeakingFunc mocks the Speaking method.
	SpeakingFunc func(in1 bool) error

	// WriteFunc mocks the Write method.
	WriteFunc func(in1 context.Context, in2 [][]byte) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Speaking holds details about calls to the Speaking method.
		Speaking []struct {
			// In1 is the in1 argument value.
			In1 bool
		}
		// Write holds details about calls to the Write method.
		Write []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 [][]byte
		}
	}
}

// Close calls CloseFunc.
func (mock *VCMock) Close() error {
	if mock.CloseFunc == nil {
		panic("VCMock.CloseFunc: method is nil but VC.Close was just called")
	}
	callInfo := struct {
	}{}
	lockVCMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockVCMockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedVC.CloseCalls())
func (mock *VCMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockVCMockClose.RLock()
	calls = mock.calls.Close
	lockVCMockClose.RUnlock()
	return calls
}

// Speaking calls SpeakingFunc.
func (mock *VCMock) Speaking(in1 bool) error {
	if mock.SpeakingFunc == nil {
		panic("VCMock.SpeakingFunc: method is nil but VC.Speaking was just called")
	}
	callInfo := struct {
		In1 bool
	}{
		In1: in1,
	}
	lockVCMockSpeaking.Lock()
	mock.calls.Speaking = append(mock.calls.Speaking, callInfo)
	lockVCMockSpeaking.Unlock()
	return mock.SpeakingFunc(in1)
}

// SpeakingCalls gets all the calls that were made to Speaking.
// Check the length with:
//     len(mockedVC.SpeakingCalls())
func (mock *VCMock) SpeakingCalls() []struct {
	In1 bool
} {
	var calls []struct {
		In1 bool
	}
	lockVCMockSpeaking.RLock()
	calls = mock.calls.Speaking
	lockVCMockSpeaking.RUnlock()
	return calls
}

// Write calls WriteFunc.
func (mock *VCMock) Write(in1 context.Context, in2 [][]byte) error {
	if mock.WriteFunc == nil {
		panic("VCMock.WriteFunc: method is nil but VC.Write was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 [][]byte
	}{
		In1: in1,
		In2: in2,
	}
	lockVCMockWrite.Lock()
	mock.calls.Write = append(mock.calls.Write, callInfo)
	lockVCMockWrite.Unlock()
	return mock.WriteFunc(in1, in2)
}

// WriteCalls gets all the calls that were made to Write.
// Check the length with:
//     len(mockedVC.WriteCalls())
func (mock *VCMock) WriteCalls() []struct {
	In1 context.Context
	In2 [][]byte
} {
	var calls []struct {
		In1 context.Context
		In2 [][]byte
	}
	lockVCMockWrite.RLock()
	calls = mock.calls.Write
	lockVCMockWrite.RUnlock()
	return calls
}
